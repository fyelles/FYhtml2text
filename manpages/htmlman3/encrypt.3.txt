

Linux
          manual pages
Section 3
 

 
 

Name
encrypt, setkey, encrypt_r, setkey_r — encrypt
      64-bit messages

Synopsis

#define _XOPEN_SOURCE        /* See feature_test_macros(7) */
#include <unistd.h>

void
            encrypt(
char block[64],

 
int edflag);

           
        

#define _XOPEN_SOURCE        /* See feature_test_macros(7) */
#include <stdlib.h>

void
            setkey(
const char *key);

           
        

#define _GNU_SOURCE          /* See feature_test_macros(7) */
#include <crypt.h>

void
            setkey_r(
const char *key,

 
struct crypt_data *data);

           
        

void
            encrypt_r(
char *block,

 
int edflag,

 
struct crypt_data *data);

           
        

Each of these requires linking with −lcrypt.
  

 
DESCRIPTION
These functions encrypt and decrypt 64-bit messages. The
      setkey() function sets the key
      used by encrypt(). The
      key argument used
      here is an array of 64 bytes, each of which has numerical
      value 1 or 0. The bytes key[n] where n=8*i-1 are ignored, so
      that the effective key length is 56 bits.
The encrypt() function
      modifies the passed buffer, encoding if edflag is 0, and decoding if 1
      is being passed. Like the key argument, also block is a bit vector
      representation of the actual value that is encoded. The
      result is returned in that same vector.
These two functions are not reentrant, that is, the key
      data is kept in static storage. The functions setkey_r() and encrypt_r() are the reentrant versions.
      They use the following structure to hold the key data:

                  struct
crypt_data {

 
char

                   
keysched[16 * 8];
 

 
char

                   
sb0[32768];
 

 
char

                   
sb1[32768];
 

 
char

                   
sb2[32768];
 

 
char

                   
sb3[32768];
 

 
char

                   
crypt_3_buf[14];
 

 
char

                   
current_salt[2];
 

 
long int

                   
current_saltbits;
 

 
int

                   
direction;
 

 
int

                   
initialized;
 

};

Before calling setkey_r()
      set data−>initialized to
      zero.

 
RETURN VALUE
These functions do not return any value.

 
ERRORS
Set errno to zero before
      calling the above functions. On success, it is unchanged.

ENOSYS

The function is not provided. (For example because
            of former USA export restrictions.)

 
CONFORMING TO
The functions encrypt() and
      setkey() conform to SVr4,
      SUSv2, and POSIX.1-2001. The functions encrypt_r() and setkey_r() are GNU extensions.

 
NOTES
In glibc 2.2 these functions use the DES algorithm.

 
EXAMPLE
You need to link with libcrypt to compile this example
      with glibc. To do useful work the key[] and txt[] arrays must be filled
      with a useful bit pattern.

#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdlib.h>

int
main(void)
{
    char key[64];      /* bit pattern for key */
    char txt[64];      /* bit pattern for messages */

    setkey(key);
    encrypt(txt, 0);   /* encode */
    encrypt(txt, 1);   /* decode */
}

 
SEE ALSO
cbc_crypt(3), crypt(3), ecb_crypt(3),

 
COLOPHON
This page is part of release 3.33 of the Linux man-pages project. A
      description of the project, and information about reporting
      bugs, can be found at http://man7.org/linux/man-pages/.

                    Copyright 2000 Nicolás Lichtmaier <nickdocument.write('@');(@)debian.org>

                  Created 2000-07-22 00:52-0300

                  This is free documentation; you can redistribute it and/or

                  modify it under the terms of the GNU General Public License as

                  published by the Free Software Foundation; either version 2 of

                  the License, or (at your option) any later version.

                  The GNU General Public License's references to "object code"

                  and "executables" are to be interpreted as the output of any

                  document formatting or typesetting system, including

                  intermediate and printed output.

                  This manual is distributed in the hope that it will be useful,

                  but WITHOUT ANY WARRANTY; without even the implied warranty of

                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

                  GNU General Public License for more details.

                  Modified 2002-07-23 19:21:35 CEST 2002 Walter Harms

                  <walter.harmsdocument.write('@');(@)informatik.uni-oldenburg.de>

                  Modified 2003-04-04, aeb

